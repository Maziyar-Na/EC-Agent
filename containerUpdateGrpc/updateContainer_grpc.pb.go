// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package containerUpdate

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ContainerUpdateHandlerClient is the client API for ContainerUpdateHandler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContainerUpdateHandlerClient interface {
	// Sends a greeting
	ReqQuotaUpdate(ctx context.Context, in *ContainerQuotaRequest, opts ...grpc.CallOption) (*ContainerQuotaReply, error)
	ReqResizeMaxMem(ctx context.Context, in *ResizeMaxMemRequest, opts ...grpc.CallOption) (*ResizeMaxMemReply, error)
	ReadMemUsage(ctx context.Context, in *CgroupId, opts ...grpc.CallOption) (*ReadMemUsageReply, error)
	ReadMemLimit(ctx context.Context, in *CgroupId, opts ...grpc.CallOption) (*ReadMemLimitReply, error)
}

type containerUpdateHandlerClient struct {
	cc grpc.ClientConnInterface
}

func NewContainerUpdateHandlerClient(cc grpc.ClientConnInterface) ContainerUpdateHandlerClient {
	return &containerUpdateHandlerClient{cc}
}

func (c *containerUpdateHandlerClient) ReqQuotaUpdate(ctx context.Context, in *ContainerQuotaRequest, opts ...grpc.CallOption) (*ContainerQuotaReply, error) {
	out := new(ContainerQuotaReply)
	err := c.cc.Invoke(ctx, "/ec.rpc.containerUpdate.ContainerUpdateHandler/ReqQuotaUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerUpdateHandlerClient) ReqResizeMaxMem(ctx context.Context, in *ResizeMaxMemRequest, opts ...grpc.CallOption) (*ResizeMaxMemReply, error) {
	out := new(ResizeMaxMemReply)
	err := c.cc.Invoke(ctx, "/ec.rpc.containerUpdate.ContainerUpdateHandler/ReqResizeMaxMem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerUpdateHandlerClient) ReadMemUsage(ctx context.Context, in *CgroupId, opts ...grpc.CallOption) (*ReadMemUsageReply, error) {
	out := new(ReadMemUsageReply)
	err := c.cc.Invoke(ctx, "/ec.rpc.containerUpdate.ContainerUpdateHandler/ReadMemUsage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerUpdateHandlerClient) ReadMemLimit(ctx context.Context, in *CgroupId, opts ...grpc.CallOption) (*ReadMemLimitReply, error) {
	out := new(ReadMemLimitReply)
	err := c.cc.Invoke(ctx, "/ec.rpc.containerUpdate.ContainerUpdateHandler/ReadMemLimit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContainerUpdateHandlerServer is the server API for ContainerUpdateHandler service.
// All implementations must embed UnimplementedContainerUpdateHandlerServer
// for forward compatibility
type ContainerUpdateHandlerServer interface {
	// Sends a greeting
	ReqQuotaUpdate(context.Context, *ContainerQuotaRequest) (*ContainerQuotaReply, error)
	ReqResizeMaxMem(context.Context, *ResizeMaxMemRequest) (*ResizeMaxMemReply, error)
	ReadMemUsage(context.Context, *CgroupId) (*ReadMemUsageReply, error)
	ReadMemLimit(context.Context, *CgroupId) (*ReadMemLimitReply, error)
	mustEmbedUnimplementedContainerUpdateHandlerServer()
}

// UnimplementedContainerUpdateHandlerServer must be embedded to have forward compatible implementations.
type UnimplementedContainerUpdateHandlerServer struct {
}

func (UnimplementedContainerUpdateHandlerServer) ReqQuotaUpdate(context.Context, *ContainerQuotaRequest) (*ContainerQuotaReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqQuotaUpdate not implemented")
}
func (UnimplementedContainerUpdateHandlerServer) ReqResizeMaxMem(context.Context, *ResizeMaxMemRequest) (*ResizeMaxMemReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReqResizeMaxMem not implemented")
}
func (UnimplementedContainerUpdateHandlerServer) ReadMemUsage(context.Context, *CgroupId) (*ReadMemUsageReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadMemUsage not implemented")
}
func (UnimplementedContainerUpdateHandlerServer) ReadMemLimit(context.Context, *CgroupId) (*ReadMemLimitReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadMemLimit not implemented")
}
func (UnimplementedContainerUpdateHandlerServer) mustEmbedUnimplementedContainerUpdateHandlerServer() {
}

// UnsafeContainerUpdateHandlerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContainerUpdateHandlerServer will
// result in compilation errors.
type UnsafeContainerUpdateHandlerServer interface {
	mustEmbedUnimplementedContainerUpdateHandlerServer()
}

func RegisterContainerUpdateHandlerServer(s grpc.ServiceRegistrar, srv ContainerUpdateHandlerServer) {
	s.RegisterService(&ContainerUpdateHandler_ServiceDesc, srv)
}

func _ContainerUpdateHandler_ReqQuotaUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerQuotaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerUpdateHandlerServer).ReqQuotaUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ec.rpc.containerUpdate.ContainerUpdateHandler/ReqQuotaUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerUpdateHandlerServer).ReqQuotaUpdate(ctx, req.(*ContainerQuotaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerUpdateHandler_ReqResizeMaxMem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResizeMaxMemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerUpdateHandlerServer).ReqResizeMaxMem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ec.rpc.containerUpdate.ContainerUpdateHandler/ReqResizeMaxMem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerUpdateHandlerServer).ReqResizeMaxMem(ctx, req.(*ResizeMaxMemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerUpdateHandler_ReadMemUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CgroupId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerUpdateHandlerServer).ReadMemUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ec.rpc.containerUpdate.ContainerUpdateHandler/ReadMemUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerUpdateHandlerServer).ReadMemUsage(ctx, req.(*CgroupId))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerUpdateHandler_ReadMemLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CgroupId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerUpdateHandlerServer).ReadMemLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ec.rpc.containerUpdate.ContainerUpdateHandler/ReadMemLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerUpdateHandlerServer).ReadMemLimit(ctx, req.(*CgroupId))
	}
	return interceptor(ctx, in, info, handler)
}

// ContainerUpdateHandler_ServiceDesc is the grpc.ServiceDesc for ContainerUpdateHandler service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContainerUpdateHandler_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ec.rpc.containerUpdate.ContainerUpdateHandler",
	HandlerType: (*ContainerUpdateHandlerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReqQuotaUpdate",
			Handler:    _ContainerUpdateHandler_ReqQuotaUpdate_Handler,
		},
		{
			MethodName: "ReqResizeMaxMem",
			Handler:    _ContainerUpdateHandler_ReqResizeMaxMem_Handler,
		},
		{
			MethodName: "ReadMemUsage",
			Handler:    _ContainerUpdateHandler_ReadMemUsage_Handler,
		},
		{
			MethodName: "ReadMemLimit",
			Handler:    _ContainerUpdateHandler_ReadMemLimit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "updateContainer.proto",
}
